# Android CI/CD Pipeline
# 
# This GitHub Actions workflow provides automated continuous integration and deployment
# for the ShoppingApp multi-module Android project. It ensures code quality, runs tests,
# and builds the application automatically on every push and pull request.
#
# Why this is required:
# - Ensures consistent code quality across all contributions
# - Automatically catches build failures and test regressions
# - Validates that all modules compile and integrate correctly
# - Provides fast feedback to developers on code changes
# - Enables confident releases through automated verification
#
# PARALLEL EXECUTION STRATEGY:
# The workflow runs three parallel jobs for efficiency:
# 1. Lint Check - Validates code style and detects potential issues
# 2. Unit Tests - Runs all module tests to ensure functionality
# 3. Build APK - Compiles the complete application to verify integration
#
# Rationale for Parallel Execution:
# - FASTER FEEDBACK: Reduces total CI time from ~15 minutes (sequential) to ~5 minutes (parallel)
# - EFFICIENT RESOURCE USAGE: Leverages GitHub's concurrent runner capacity
# - INDEPENDENT VALIDATION: Each job validates different aspects without dependencies
# - MULTI-MODULE OPTIMIZATION: Perfect for modular architecture where different aspects
#   can be validated simultaneously across all modules:
#   * CODE STYLE: Lint job validates code quality across core modules (model, ui, network) 
#     and feature modules (categories, categoryproducts, productdetail) simultaneously
#   * BUSINESS LOGIC: Test job runs unit tests for each module's domain logic independently
#     (e.g., repository tests in core:network, use case tests in feature modules)
#   * INTEGRATION: Build job verifies that all modules compile and integrate correctly
#     (app module depends on features, features depend on core modules)
#   This parallel validation is especially valuable in multi-module projects because each
#   module can have issues in different areas - style problems in one feature, test failures
#   in another, or integration issues between core and feature modules.
# - DEVELOPER PRODUCTIVITY: Quicker identification of which specific area has issues
#
# FAILURE HANDLING & RECOVERY FLOW:
# - INDEPENDENT EXECUTION: Each job runs independently; failure of one doesn't stop others
# - PARTIAL RESULTS: If lint fails but tests pass, developers get specific feedback about code style issues
# - COMPREHENSIVE REPORTING: All job results are available even if some fail, enabling targeted fixes
# - WORKFLOW STATUS: Overall workflow fails if ANY job fails, ensuring quality gates are maintained
# - RECOVERY PROCESS: Developers can push targeted fixes (e.g., style-only changes for lint failures)
#   without re-running unnecessary jobs that already passed

name: Android CI

# Trigger conditions: Run on pushes and pull requests to main/develop branches
on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  # Job 1: Code Quality Analysis
  # Runs Android lint to check for code style issues, potential bugs,
  # and adherence to Android development best practices
  lint:
    name: Lint Check
    runs-on: ubuntu-latest
    
    steps:
    # Checkout the repository code
    - uses: actions/checkout@v4
    
    # Set up Java 17 environment (required for Android Gradle Plugin 8.7.2+)
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    # Cache Gradle dependencies to speed up builds
    # This prevents re-downloading dependencies on every run
    #
    # CACHE STORAGE & SHARING DETAILS:
    # - STORAGE LOCATION: GitHub's backend cache storage (managed infrastructure)
    # - SHARING SCOPE: Cache is shared across:
    #   * All branches in the same repository
    #   * All pull requests targeting the same repository
    #   * Different workflow runs on the same runner OS
    # - CACHE KEY STRATEGY: Generated from OS + hash of gradle files
    #   * Exact match: Uses cache if gradle files haven't changed
    #   * Partial match: Falls back to restore-keys for similar caches
    # - EVICTION POLICY: 
    #   * 7-day retention period (automatically cleaned after 7 days)
    #   * 10GB total limit per repository (oldest caches evicted first)
    #   * Unused caches are cleaned more aggressively
    # - PERFORMANCE IMPACT: 
    #   * Cache hit: ~30-60 seconds saved on dependency resolution
    #   * Cache miss: Small overhead (~5-10 seconds) for cache save/restore
    #   * Network efficiency: Reduces external dependency downloads by ~90%
    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
    
    # Make gradlew executable (required on Unix systems)
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew

    # ---------------------------------------------------------------------------
    # Pre-fetch Gradle Dependencies
    #
    # WHY IS THIS STEP NEEDED?
    # - GitHub Actions runners have two phases of network access:
    #   1. Setup phase (before firewall rules apply): external downloads allowed.
    #   2. Execution phase (firewall active): outbound requests to domains like
    #      dl.google.com or mvnrepository.com may be blocked.
    #
    # WHAT THIS STEP DOES:
    # - Forces Gradle to resolve and download *all required dependencies* early,
    #   while network access is still open.
    # - Stores dependencies into the local Gradle cache (~/.gradle).
    # - Later steps (lint, test, build) can then run fully offline from cache,
    #   avoiding firewall errors.
    #
    # EXTRA DETAILS:
    # - "--no-daemon" avoids Gradle daemon issues on CI runners.
    # - "|| true" ensures that the job does not fail if some subprojects
    #   have no dependencies (Gradle may otherwise exit with non-zero).
    #
    # BENEFITS:
    # - Firewall-safe builds (no blocked network calls).
    # - More reliable caching between workflow runs.
    # - Faster builds after warm-up.
    # ---------------------------------------------------------------------------
    - name: Pre-fetch Gradle dependencies
      run: ./gradlew --no-daemon dependencies || true
    
    # Run lint across all modules to check code quality
    - name: Run lint
      run: ./gradlew lint

  # Job 2: Automated Testing
  # Runs unit tests across all modules to ensure functionality
  # and catch regressions in business logic
  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    
    steps:
    # Checkout the repository code
    - uses: actions/checkout@v4
    
    # Set up Java 11 environment
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    # Cache Gradle dependencies for faster builds
    # See detailed cache documentation in the lint job above for complete explanation
    # of storage location, sharing scope, eviction policies, and performance impact
    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
    
    # Make gradlew executable
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew

    # ---------------------------------------------------------------------------
    # Pre-fetch Gradle Dependencies
    #
    # WHY IS THIS STEP NEEDED?
    # - GitHub Actions runners have two phases of network access:
    #   1. Setup phase (before firewall rules apply): external downloads allowed.
    #   2. Execution phase (firewall active): outbound requests to domains like
    #      dl.google.com or mvnrepository.com may be blocked.
    #
    # WHAT THIS STEP DOES:
    # - Forces Gradle to resolve and download *all required dependencies* early,
    #   while network access is still open.
    # - Stores dependencies into the local Gradle cache (~/.gradle).
    # - Later steps (lint, test, build) can then run fully offline from cache,
    #   avoiding firewall errors.
    #
    # EXTRA DETAILS:
    # - "--no-daemon" avoids Gradle daemon issues on CI runners.
    # - "|| true" ensures that the job does not fail if some subprojects
    #   have no dependencies (Gradle may otherwise exit with non-zero).
    #
    # BENEFITS:
    # - Firewall-safe builds (no blocked network calls).
    # - More reliable caching between workflow runs.
    # - Faster builds after warm-up.
    # ---------------------------------------------------------------------------
    - name: Pre-fetch Gradle dependencies
      run: ./gradlew --no-daemon dependencies || true
    
    # Execute all unit tests across feature and core modules
    - name: Run unit tests
      run: ./gradlew test
    
    # Generate and publish test reports for visibility
    # This creates a detailed report of test results in the GitHub interface
    - name: Generate test report
      uses: dorny/test-reporter@v1
      if: success() || failure()    # Run even if tests fail to show results
      with:
        name: Test Results
        path: '**/build/test-results/test/TEST-*.xml'
        reporter: java-junit

  # Job 3: Build Verification
  # Compiles the complete application to ensure all modules integrate correctly
  # and generates a deployable APK artifact
  build:
    name: Build APK
    runs-on: ubuntu-latest
    
    steps:
    # Checkout the repository code
    - uses: actions/checkout@v4
    
    # Set up Java 11 environment
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    # Cache Gradle dependencies for faster builds
    # See detailed cache documentation in the lint job above for complete explanation
    # of storage location, sharing scope, eviction policies, and performance impact
    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
    
    # Make gradlew executable
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew

    # ---------------------------------------------------------------------------
    # Pre-fetch Gradle Dependencies
    #
    # WHY IS THIS STEP NEEDED?
    # - GitHub Actions runners have two phases of network access:
    #   1. Setup phase (before firewall rules apply): external downloads allowed.
    #   2. Execution phase (firewall active): outbound requests to domains like
    #      dl.google.com or mvnrepository.com may be blocked.
    #
    # WHAT THIS STEP DOES:
    # - Forces Gradle to resolve and download *all required dependencies* early,
    #   while network access is still open.
    # - Stores dependencies into the local Gradle cache (~/.gradle).
    # - Later steps (lint, test, build) can then run fully offline from cache,
    #   avoiding firewall errors.
    #
    # EXTRA DETAILS:
    # - "--no-daemon" avoids Gradle daemon issues on CI runners.
    # - "|| true" ensures that the job does not fail if some subprojects
    #   have no dependencies (Gradle may otherwise exit with non-zero).
    #
    # BENEFITS:
    # - Firewall-safe builds (no blocked network calls).
    # - More reliable caching between workflow runs.
    # - Faster builds after warm-up.
    # ---------------------------------------------------------------------------
    - name: Pre-fetch Gradle dependencies
      run: ./gradlew --no-daemon dependencies || true
    
    # Build the debug APK to verify complete integration
    # This ensures all modules compile together successfully
    - name: Build with Gradle
      run: ./gradlew assembleDebug
    
    # Upload the generated APK as an artifact
    # This allows downloading the built app for testing or deployment
    - name: Upload APK
      uses: actions/upload-artifact@v4
      with:
        name: app-debug
        path: app/build/outputs/apk/debug/app-debug.apk
